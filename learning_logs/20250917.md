```sql
SELECT u.id, u.username, u.phone, o.id,od.product_id
	FROM (users u LEFT JOIN orders o ON u.id = o.user_id)
		LEFT JOIN orderdetails od ON o.id = od.order_id
	ORDER BY u.id;
```

- FROM 내에서는 JOIN을 중첩해서 사용 가능. 이상의 경우에서는 첫 번째 JOIN의 ON절 뒤에, 두번째 JOIN을 작성했다고 볼 수 있습니다. 필요한 정보가 셋 이상의 테이블에 나뉘어 있어도, 키 값을 기반으로 연결할 수 있다면 한 번에 조회할 수 있습니다.(근데 서브쿼리 배우면 대부분 서브쿼리 쓰겠다고 하다가 망하는 경우가 많다.). 예제 쿼리는 LEFT OUTER JOIN을 통해 주문 정보가 없는 회원의 주문 정보를 포함 했고, INNER JOIN을 통해 orders / orderdetails의 교집합 정보만 출력 했다.

예제 : users와 orders를 하나로 결합 하는데, 회원 정보가 없는 주문 정보도 출력 할 수 있도록 작성하시오.

```sql
# 이건 주문 내역이 있는 회원만 출력
SELECT *
  FROM users u
  RIGHT JOIN orders o
  ON u.id = o.user_id
  ORDER BY u.id
  ;
#
```

이상의 경우에는 차 집합 개념을 들 수 있는데, 그렇다면 LEFT JOIN과 동일한 기능을 하는 것 처럼 보입니다. 하지만 INNER JOIN과 결과 값이 같죠 (즉, 주문 내역이 없는 회원 정보는 출려되지 않았음을 의미합니다.)

보통 기업에서는 먼저 나온 테이블이 기준이 되도록 해서 LEFT JOIN만 쓰거나 먼저 교집합만 사용하기 위해 INNER JOIN을 쓴다고 봐도 무방하다.

users와 orders의 _모든 가능한 행 조합_ 을 만들어내는 SQL 쿼리를 작성하시오.

```sql
SELECT *
	FROM users u
	CROSS JOIN orders o
	ORDER BY u.id
	;
```

- CROSS JOIN은 두 집합을 _조합_ 해 만들 수 있는 _카테시안 곱(cartesian product)_ 을 출력한다. 모든 조합이 나오기 때문에 LEFT / RIGTH / INNER JOIN처럼 조건이 따로 필요하지는 않다.
- 출력하는 결과값은 각 두 테이블의 모든 조합 가능한 경우에 수 이기 때문에 출력 나오는 경우 이외의 경우의 수는 존재 하지 않는다.
- 실제 운용단계에서는 CROSS JOIN이 많은 리소스를 잡아 먹기 때문에 사용은 지양하는 편인다.

- FULL OUTER JOIN = LEFT JOIN + RIGHT JOIN - INNER JOIN

# JOIN 정리

- JOIN은 복수의 테이블을 하나로 결합할 때 사용. 여러 곳에 기록된 (정규환된) 데이터를 마치 하나의 테이블 처럼 합칠 때 필요.
  형식:
  `FROM 테이블1 a (LEFT/INNER) JOIN 테이블2 b ON a.PK = b.FK;`
  JOIN은 FROM절에서 수행 되기 때문에 가장 먼저 실행된다.
- 조건에서 볼 수 있듯 공통된 컬럼 값인 키 값이 존재해야만 JOIN으로 결합 할 수 있다. 키 값은 여러개가 있을 수 있어, 어떤 값을 기준으로 할지 ON에서 명시합니다.
- 또한 JOIN의 중첩도 가능하다.
  형식:
  `FROM 테이블1 a (LEFT/INNER) JOIN 테이블2 b  ON a.PK = b.FK (LEFT/INNER) JOIN 테이블3 c ON 조건어쩌고 = c.FK;`

## 종류

- INNER JOIN : 각 테이블의 키 값이 일치하는 행만(교집합만) 출력한다. 가장 기본적인 default JOIN이기 때문에 INNER 생략이 가능하다. 그러나 가독성의 문제로 INNER를 작성하는것을 권장한다.
- LEFT (OUTER) JOIN : 왼쪽 테이블의 모든데이터를 결과에 포함시켜서 출력.
- RIGHT (OUTER) JOIN : 오른쪽 테이블의 모든데이터를 결과에 포함시켜서 출력.
- FULL OUTER JOIN : 좌우측 모든 테이블의 모든 데이터를 결과에 포함시켜서 출력
- CROSS JOIN : 좌우측 모든 테이블의 조합 가능한 모든 조건을 출력한다. 위 4가지의 JOIN과는 다르게 조건이 필요 없다.

## 연습문제

1. users아 staff를 참고하여 회원 중 직원인 사람의 회원 아이디, 이메일, 거주도시, 거주 국가, 성, 이름을 한 화면에 출력

```SQL
SELECT u.id, u.username, u.city, u.country, s.first_name, s.last_name
	FROM users u INNER JOIN staff s
	ON u.id = s.user_id
	ORDER BY u.id;
```

2. staff와 orders를 참고하여 직원 아이디가 3번, 5번인 직원의 담당 주문을 출력 (단 직원 아이디, 직원의 성, 주문 아이디, 주문 일자만 출력 할 것)

```SQL
SELECT s.id, s.first_name, o.id, o.order_date
	FROM staff s
	INNER JOIN orders o
	ON s.id = o.staff_id
	WHERE s.id IN (3, 5)
	ORDER BY s.id;
```

3. users와 orders를 참고하여 국가별 주문건수를 내림차순으로 출력

```SQL
SELECT u.country , COUNT(DISTINCT o.id) AS orderCnt
	FROM users u INNER JOIN orders o
	ON u.id = o.user_id
	GROUP BY u.country
	ORDER BY orderCnt desc;
```

4. orders와 orderdetails, products를 참고하여 회원 아이디 별 주문 금액의 총합을 정상 가격과 할인 가격 기준으로 각각 추출하시오. 단 정상 가격 주문 금액의 총합 기준으로 내림차순 하시오.

```SQL
SELECT o.user_id, ROUND(SUM(p.price * od.quantity),2) AS sumPrice, ROUND(SUM(p.discount_price * od.quantity), 2) AS sumDisPrice
	FROM orders o INNER JOIN orderdetails od
	ON o.id = od.order_id
	INNER JOIN products p
	ON od.product_id = p.id
	GROUP BY o.user_id
	ORDER BY sumPrice desc;
```

5. 다음 조건의 테이블이 있다고 가정합니다.
   - 왼쪽테이블 A: 컬럼 개수 5개 / 150행
   - 오른쪽 테이블 B : 컬럼개수 7개 / 100행
   - 두 테이블은 고통 키 값 컬럼을 1개 보유
     이상의 조건의 테이블을 기준으로 CROSS/LEFT/RIGHT/INNER JOIN을 했을 때 뷰의 행과 열 개수를 계산
     답 - 행: 15000개 열 : 12개 / 행: 150개 열 : 12개 / 행: 100개 열 : 12개 / 행: 0개 열 : 12개

# UNION

## 컬럼 목록이 같은 데이터를 위 아래로 결합

- 데이터를 위아래로 수직 결합을 지원하는 UNION은 컬럼의 형식돠 개수가 같은 두 데이터 결과 집합을 하나로 합친다고 볼 수 있다.
- 조건을 설정해서 결합해야하는 JOIN과 달리, UNION은 컬럼의 형식/ 개수만 동일하면 어떻게든 결합이 가능하다.

예시 : users를 full scan한 결과 집합해서 UNION 적용

```sql
(SELECT * FROM users )
UNION
(SELECT * FROM users )
```

이상의 쿼리를 실행해봤을 때 결과가 `SELECT * FROM users;`과 동일합니다.
_UNION_ 은 중복 제거 기능이 있습니다.

예시 : users 에 full scan한 결과 집합해서 UNION ALL 적용

UNION의 기본 전제 : 컬럼의 형식 /개수 -> SELECT 수행 이후에 커스텀한 칼럼에서도 동일하게 적용 된다.

```SQL
(SELECT * FROM users) UNION ALL (SELECT id, phone, country, city FROM users);
```

그래서 이상의 쿼리문의 실행 결과는 오류가 발생합니다.
같은 users테이블에서 값이 나왔다 하더라도 SELECT문을 이용하여 결국 컬럼을 커스텀 하였기 때문에 컬럼이 일치하지 않게 되어 오류가 발생한다.

연습 : usersd에서 country가 korea인 회원정보만 추출하고, Mexico인 회원 정보만 추출하여 결합하여. 컬럼은 id, phone, city, county만 출력하고 최동 결과 집합은 county기준으로 알파벨 순으로 정렬

## UNION 정리

컬럼 형식 / 개수 조정이 중요합니다.
중복 제거가 들어가 있다.
중복 상관 없는경우 UNION ALL을 쓴다.

연습문제 :

1. orders에서 order_date가 2015 10월인 건과 2015년 12월인 건을 SELECT로 각각 추출하고, 두 결과 집합을 UNION ALL 을 사용해 하나로 결합할 것 ( 단, 결과는 최신 순으로 정렬한다.)

```sql
(SELECT * FROM orders WHERE SUBSTR(order_date,1,7) = '2015-10')
UNION ALL
(SELECT * FROM orders WHERE SUBSTR(order_date,1,7) = '2015-12')
ORDER BY order_date desc;
```

2. users에서 USA에 거주 중이면서 마케팅 수신 동의를 한 회원 정보와 France에서 거주중이면서 마케팅 수신에 동의하지 않은 회원 정보를 selecet로 각각 추출하고, 두 결과 집합을 UNION ALL을 사용해 하나로 결합할 것 (단, 최종 결과는 id, phone, country, city, is_marketing_agree 컬럼만 출력 하고, 거주 국가 기준 알파벳 순으로 정렬)

```sql
(SELECT id, phone, country, city, is_marketing_agree FROM users WHERE country = 'USA' AND is_marketing_agree = 1)
UNION ALL
(SELECT id, phone, country, city, is_marketing_agree FROM users WHERE country = 'France' AND is_marketing_agree = 0)
ORDER BY country;
```

3. UNION을 활용하여 orderdetais와 products를 FULL OUTER JOIN으로 결합하여 출력할 것.

```sql
(SELECT * FROM products p LEFT JOIN orderdetails od ON p.id = od.product_id)
UNION
(SELECT * FROM products p RIGHT JOIN orderdetails od ON p.id = od.product_id);
```

# Sub Query

- SQL의 쿼리 결과를 테이블 처럼 사용하는 쿼리 내부의 쿼리.
- 기존에는 데이터를 결합할 때 이미존재하는 테이블에 접근하여 결합을 시도했습니다. 하지만 이제부터는 기존 테이블을 편집하여 만든 결과값을 기준으로 다시 쿼리를 실행하는 형태로 이루어진다.

즉, 개발자가 작성한 쿼리를 실행하여 나온 결과값을 테이블 처럼 사용하거나 조건 또는 값으로 사용에 관한 내용이다.

서브 쿼리는 SELECT 문 내의 여러 곳에서 사용이 가능한다, 사용하는 위치에 따라 불리는 이름이 다양하다.
그래서 서브 쿼리 하나로 퉁치면 안되고 어떤 서브쿼리인지 아는게 그 와중에 SQLD에서 시험에 나온다.

예제 : products에서 제품명과, 정상가격을 모두 불러오고 평균 정상 가격을 새로운 컬럼으로 각 행마다 출력하시오.

```sql
SELECT NAME, price, (SELECT ROUND(AVG(price),2)FROM products) AS avgPrice  FROM products
```

`SELECT ROUND(AVG(price),2)FROM products` 의 결과 값은 : 전체 price들의 총합을 row 개수만큼 나눈 평균 값에 해당하며 해당 쿼리의 결과는 행과 열이 모두 1일 테이블이 나온다.

그리고 이 단일한 결과값이 나온 테이블을

```sql
SELECT name, prSELECT NAME, price, (SELECT ROUND(AVG(price),2)FROM products) AS avgPrice  FROM products
```

이렇게 적용시키면 저체 테이블은 name, price, avgProduct로 이루어진 세개의 컬럼을 지닌 테이블이 나오게 될텐데, 서브쿼리의 결과가 하나의 값만 있기 때문에 모든 row에 SEKECT AVG(price) FROM products의 결과값이 붙어서 출력된다.

이처럼 SELECT절에는 '단일 값을 반환'하는 서브쿼리가 올수 있는데 이를 '스칼라(Scalar) 서브쿼리'라고 한다.

위 예와 같이 스칼라 서브쿼리는 신규컬럼으로 추가되어 모든 행에 단일 값을 출력한다.

```sql
SELECT NAME, price, 100.0 AS fakePrice, (SELECT ROUND(AVG(price),2)FROM products) AS avgPrice  FROM products
```

이와 같이 단 하나의 값만 있어야 하기 때문에 스칼라 서브 쿼리를 사용하게 된다면 값을 하나만 나오도록 서브쿼리를 작성하거나 작성한 서브 쿼리가 1개의 값만 나오도록 이해를 하고 있어야 한다.

정상가 기준의 avgPrice avgDiscountPrice도 추가하고 싶다면 서브 쿼리 두 개가 병렬로 있어야 할 겁니다..

```sql
SELECT name, price,
  (SELECT ROUND(AVG(price),2)FROM products) AS avgPrice,
  (SELECT ROUND(AVG(discount_price),2)FROM products) AS avgDiscountPrice
  FROM products
```

예제 : users에서 city 별 회원 수를 카운트 하고, 회원 수가 3명 이상인 도시명과 회원수를 출력할 것 (단, 회원 수를 기준으로 내림 차순 정렬)

```sql
SELECT *
	FROM (
			SELECT city, COUNT(DISTINCT id) AS userCnt FROM users GROUP BY city
			) temp
	WHERE userCnt > 2
	ORDER BY userCnt DESC;
```

이상과 같이 FROM절 내에 서브 쿼리가 들어가는 것을 인라인 뷰라고 한다.

## Inline View

특징:

1. 인라인 뷰 내에는 또 다른 서브 쿼리가 개수 제한 없이 중첩적으로 들어갈 수 있다.
2. 인라인 뷰의 서브 쿼리는 괄호 안에 작성한 쿼리의 결과값 자체를 테이블에 존재하는 데이터로 간주하고, 이에 대한 로직을 수행한다.
3. 인라인 뷰는 기존 FROM절에 오는 다른 테이블과 달리 이름을 지정하지 않으면 사용할 수 없다.

## WHERE 절 내부의 서브쿼리

예제 : oreders에서 staff를 활용하여 last_name의 값이 kyle이나 Scott인 지원의 담당 주문을 출력.

```sql
SELECT *
	FROM orders
	WHERE staff_id IN (
							SELECT id
							FROM staff
						   WHERE last_name IN('Kyle','Scott')
						   )
	ORDER BY staff_id;
```

kyle의 스테프 아이디는 3이고 scott의 스태프 아이디는 5입니다. 이를 가지고 orders 테이블의 staff_id와 연결하여 원하는 정보를 출력하는 쿼리입니다.
WHERE staff_id IN() 안에 들어가는 값이 여러개의 행이 들어갈 수 있다는 것을 알 수있다.

예제 : products에서 할인 가격이 가장 비싼 제품을 출력 하시오

```sql
SELECT * FROM products ORDER BY discount_price DESC LIMIT 1;

SELECT * FROM products WHERE discount_price = (SELECT AVG(discount_price) FROM products);
```

예제 : orders에서 주문 월이 2015년 7월인 주문 정보를, orederdetails에서 개별 주문 수량이 50이상인 정보를 각각 서브쿼리로 작성하고, INNER JOIN을 활용하여 작성

```sql
SELECT *
	FROM
	(
		SELECT * FROM orders WHERE SUBSTR(order_date,1,7) = '2015-07'
	) o
	INNER JOIN
	(
		SELECT * FROM orderdetails WHERE quantity > 49
	) od
	ON o.id = od.order_id
	;
```

## 서브쿼리 정리

강사님 md 파일 복붙

연습문제

1. products를 풀 스캔하고 ,할인 가격의 최대값 대비 해당 제품의 할인 가격의 비율을 구해 ratioPerMaxPrc컬럼명으로 추가 할 것 (단, 소수점은 셋째 자리까지만 표기)

```sql
SELECT *,
 	ROUND((discount_price/(SELECT MAX(discount_price) FROM products)),3) AS ratioPerMaxPrc
	FROM products
	ORDER BY ratioPerMaxPrc DESC;
```

2. users에서 staff 테이블을 활용하여 거주 국가가 Korea나 Italy이면서 생년 월일이 1990-01-01 이전인 회원이자 직원인 사람의 정보를 출력할 것 (단, 회원 아이디/ 연락처/ 거주국가/ 직원 아이디/ 성/ 이름 컬럼 출력할 것)

```sql
SELECT u.id, u.phone, u.country, s.id, s.first_name, s.last_name
	FROM (
			SELECT *
			FROM users
			WHERE country IN ('korea' ,'italy')
			) u
			INNER JOIN
			(
			SELECT *
			FROM staff
			WHERE birth_date < '1990-01-01'
			) s
			ON u.id = s.user_id
	;
```

3. users를 활용해 country 별 회원수를 카운트 하고 5명 이상인 국가만 출력할 것 (단, 회원 수 기준 내림차순으로 정렬할 것)

```sql
SELECT country, COUNT(DISTINCT id) AS userCnt FROM users GROUP BY country HAVING userCnt > 5 ORDER BY userCnt DESC;
```

4. products에서 정상 가격이 가장 저렴한 제품의 정보를 모두 출력할 것

```sql
SELECT * FROM products WHERE price = (SELECT MIN(price) FROM products);
```

5. orders와 users를 활용해 2016년도에 주문 이력이 있는 회원 정보를 모두 출력 할것

```sql
SELECT *
	FROM users
	WHERE
		id IN (SELECT user_id
				FROM orders
				WHERE order_date BETWEEN '2016-01-01' AND '2016-12-31'
				)
	;
```
